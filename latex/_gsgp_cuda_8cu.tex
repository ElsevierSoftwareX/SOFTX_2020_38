\hypertarget{_gsgp_cuda_8cu}{}\doxysection{Gsgp\+Cuda.\+cu File Reference}
\label{_gsgp_cuda_8cu}\index{GsgpCuda.cu@{GsgpCuda.cu}}


file containing the main with the geometric semantic genetic programming algorithm  


{\ttfamily \#include \char`\"{}Gsgp\+Cuda.\+cpp\char`\"{}}\newline
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{_gsgp_cuda_8cu_a3c04138a5bfe5d72780bb7e82a18e627}{main}} (int argc, char $\ast$$\ast$argv)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
file containing the main with the geometric semantic genetic programming algorithm 

\begin{DoxyAuthor}{Author}
Jose Manuel Muñoz Contreras, Leonardo Trujillo, Daniel E. Hernandez, Perla Juárez Smith 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
created on 25/01/2020
\end{DoxyDate}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{_gsgp_cuda_8cu_a3c04138a5bfe5d72780bb7e82a18e627}\label{_gsgp_cuda_8cu_a3c04138a5bfe5d72780bb7e82a18e627}} 
\index{GsgpCuda.cu@{GsgpCuda.cu}!main@{main}}
\index{main@{main}!GsgpCuda.cu@{GsgpCuda.cu}}
\doxysubsubsection{\texorpdfstring{main()}{main()}}
{\footnotesize\ttfamily int main (\begin{DoxyParamCaption}\item[{int}]{argc,  }\item[{char $\ast$$\ast$}]{argv }\end{DoxyParamCaption})}

$<$ initialization of the seed for the generation of random numbers

$<$ select a G\+PU device

$<$ reading the parameters of the algorithm

$<$ variable that stores maximum depth for individuals

$<$ variable that stores size in bytes for initial population

$<$ variable that stores twice the size in bytes of an initial population to store random numbers

$<$ variable that stores size in bytes of the number of individuals in the initial population

$<$ variable storing twice the initial population of individuals to generate random positions

$<$ variable that stores the size in bytes of semantics for the entire population with training data

$<$ variable that stores the size in bytes of semantics for the entire population with test data

$<$ variable that stores the size in bytes the size of the training data

$<$ variable that stores the size in bytes the size of the test data

$<$ variable that stores training data elements

$<$ variable that stores test data elements

$<$ variable that stores the size in bytes of the structure to store the mutation record

$<$ variable that stores the size in bytes of the structure to store the survival record

$<$ variable that stores the size in bytes of the structure to store the survival record

$<$ variables that store the execution configuration for a kernel in the G\+PU

$<$ variables that store the execution configuration for a kernel in the G\+PU

$<$ variable that stores the size in bytes the size of the test data

$<$ name of the file with training instances

$<$ name of the file with training instances

$<$ variable name structure responsible for indicating the run

$<$ variable name structure responsible for indicating the file extension

$<$ variable name structure responsible for capturing the date and time of the run

$<$ variable that stores file name matching

$<$ pointer to the time\+Execution1 file that contains the time consumed by the different algorithm modules

$<$ variables that store the time in milliseconds between the events mark1 and mark2.

$<$ algorithm run cycle

$<$ variables that store the time in milliseconds between the events mark1 and mark2.

$<$ Variable used to create a start mark and a stop mark to create events

$<$ function that initializes the start event

$<$ function that initializes the stop event

$<$ C\+U\+DA\textquotesingle{}s random number library uses curand\+State\+\_\+t to keep track of the seed value we will store a random state for every thread

$<$ allocate space on the G\+PU for the random states

$<$ heuristic function used to choose a good block size is to aim at high occupancy

$<$ round up according to array size

$<$ invoke the G\+PU to initialize all of the random states

$<$ pointer to the file fitnesstrain.\+csv containing the training fitness of the best individual at each generation

$<$ pointer to the file fitnesstest.\+csv containing the test fitness of the best individual at each generation

$<$ the handle to the cu\+B\+L\+AS library context

$<$ initialized using the function and is explicitly passed to every subsequent library function call

$<$ This block contains the vectors of pointers to store the population and random trees and space allocation in the G\+PU

$<$ This block contains the vectors of pointers to store the structure to keep track of mutation and survival and space allocation in the G\+PU

$<$ name of the file with training instances

$<$ name of the file with test instances

$<$ name of the file with training instances

$<$ this block contains the pointer of vectors for the input data and target values ​​and assignment in the G\+PU

$<$ pointers of vectors of training and test fitness values at generation g and assignment in the G\+PU

$<$ pointer of vectors that contain the semantics of an individual in the population, calculated with the training set and test in generation g and its allocation in G\+PU

$<$ auxiliary pointer vectors for the interpreter and calculate the semantics for the populations and assignment in the G\+PU

$<$ temporal variables to perform the movement of pointers in survival

$<$ load set data train and test

$<$ round up according to array size

$<$ this section declares and initializes the variables for the events and captures the time elapsed in the initialization of the initial population in the G\+PU

$<$ invokes the G\+PU to initialize the initial population$\ast$/ initialize\+Population$<$$<$$<$ grid\+Size, block\+Size $>$$>$$>$(d\+Initial\+Population, config.\+nvar, size\+Max\+Depth\+Individual, states, config.\+max\+Random\+Constant,4); cuda\+Error\+Check(\char`\"{}initialize\+Population\char`\"{}); ~\newline
 cuda\+Event\+Record(stop\+Initial\+Pop); cuda\+Event\+Synchronize(stop\+Initial\+Pop); cuda\+Event\+Elapsed\+Time(\&initialition\+Time\+Population, start\+Initial\+Pop, stop\+Initial\+Pop); cuda\+Event\+Destroy(start\+Initial\+Pop); cuda\+Event\+Destroy(stop\+Initial\+Pop); ~\newline
 /$\ast$!$<$return the initial population of the device to the host$\ast$/ cuda\+Memcpy(h\+Initial\+Population, d\+Initial\+Population, size\+Mem\+Population, cuda\+Memcpy\+Device\+To\+Host); ~\newline
 save\+Individuals(log\+Path,h\+Initial\+Population, name\+Population, size\+Max\+Depth\+Individual,config.\+population\+Size); ~\newline
 /$\ast$!$<$ invokes the G\+PU to initialize the random trees$\ast$/ initialize\+Population$<$$<$$<$ grid\+Size, block\+Size $>$$>$$>$(d\+Random\+Trees, config.\+nvar, size\+Max\+Depth\+Individual, states, config.\+max\+Random\+Constant,4); ~\newline
 cuda\+Error\+Check(\char`\"{}initialize\+Population\char`\"{}); ~\newline
 /$\ast$!$<$return the initial population of the device to the host$\ast$/ cuda\+Memcpy(h\+Random\+Trees, d\+Random\+Trees,size\+Mem\+Population, cuda\+Memcpy\+Device\+To\+Host); ~\newline
 save\+Individuals(log\+Path,h\+Random\+Trees, name\+Random\+Trees,size\+Max\+Depth\+Individual,config.\+population\+Size); ~\newline
 cuda\+Event\+\_\+t start\+Compute\+Semantics, stop\+Compute\+Semantics; /$\ast$!$<$ This section declares and initializes the variables for the events and captures the time elapsed in the interpretation of the initial population in the G\+PU

$<$ heuristic function used to choose a good block size is to aim at high occupancy

$<$ round up according to array size

$<$ invokes the G\+PU to interpret the initial population with data train

$<$ invokes the G\+PU to interpret the random trees with data train

$<$ invokes the G\+PU to interpret the initial population with data train

$<$ invokes the G\+PU to interpret the random trees with data test

$<$ memory is deallocated for training data and auxiliary vectors for the interpreter

$<$ invokes the G\+PU to calculate the error (R\+M\+SE) the initial population

$<$ this section makes use of the isamin de cublas function to determine the position of the best individual

$<$ invokes the G\+PU to calculate the error (R\+M\+SE) the initial population

$<$ function is necessary so that the C\+PU does not continue with the execution of the program and allows to capture the fitness

$<$ writing the training fitness of the best individual on the file fitnesstrain.\+csv

$<$ writing the test fitness of the best individual on the file fitnesstest.\+csv

$<$ vectors that contain the semantics of an individual in the population, calculated in the training and test set in the g + 1 generation and its allocation in G\+PU

$<$ vector of pointers to save random positions of random trees and allocation in G\+PU

$<$ main G\+S\+GP cycle

$<$ register execution time

$<$ geometric semantic mutation with semantic train

$<$ invokes the G\+PU to calculate the error (R\+M\+SE) the new population

$<$ this section makes use of the isamin de cublas function to determine the position of the best individual of the new population

$<$ this section makes use of the isamin de cublas function to determine the position of the worst individual of the new population

$<$ geometric semantic mutation with semantic test

$<$ invokes the G\+PU to calculate the error (R\+M\+SE) the new population

$<$ set byte values

$<$ this section performs survival by updating the semantic and fitness vectors respectively

$<$ writing the test fitness of the best individual on the file fitnesstest.\+csv

$<$ at the end of the execution to deallocate memory

$<$ writing the time execution for stages the algorithm

$<$ all device allocations are removed